var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This package provides multiple algorithms for Blind Source Separation.  At this time the user can choose between JADE, Shibbs and Picard. ","category":"page"},{"location":"getting_started/#How-to-use-the-datatype-SensorData","page":"Getting Started","title":"How to use the datatype SensorData","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Key to using the package is the SensorData datatype. The user can either create a SensorData instance by loading it from disk using the readdataset() function, or he can construct his own by provididing an array of timestamps of length N and a corresponding matrix of size NxM, where M is the amount of sensors in the dataset. When the user has created a SensorData instance, he can pass it to the whitening function, plot it or perform the Blind Source separation using the performseparation function.","category":"page"},{"location":"getting_started/#Code-Example","page":"Getting Started","title":"Code Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Load a dataset from disk","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = read_dataset(\"data/foetal_ecg.dat\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Perform whitening on the dataset","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = whiten_dataset(x)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Plot dataset","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"plot_dataset(x)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Prepare JADE algorithm","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algo = Jade(size(x.data, 2))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Prepare Shibbs algorithm","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algo = Shibbs(size(x.data, 2))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Prepare Picard algorithm","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algo = Picard()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Run source separation","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = perform_separation(x, algo)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Plot again","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"plot_dataset(x)","category":"page"},{"location":"getting_started/#Complete-example:","page":"Getting Started","title":"Complete example:","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This example plots the original whitened data, as well as the results of Jade and Shibbs algorithm.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = read_dataset(\"data/foetal_ecg.dat\")\nx = whiten_dataset(x)\nplot_dataset(x)\n\nalgo = Jade(size(x.data, 2))\ny = perform_separation(x, algo)\nplot_dataset(y)\n\nalgo = Shibbs(size(x.data, 2))\nz = perform_separation(x, algo)\nplot_dataset(z)","category":"page"},{"location":"#ICA_BlindSourceSeparation","page":"Home","title":"ICA_BlindSourceSeparation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ICA_BlindSourceSeparation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ICA_BlindSourceSeparation.demo-Tuple{}","page":"Home","title":"ICA_BlindSourceSeparation.demo","text":"demo()\n\nPlots the whitened data in the foetal_ecg database.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.estimate_cumulants-Tuple{AbstractMatrix}","page":"Home","title":"ICA_BlindSourceSeparation.estimate_cumulants","text":"estimate_cumulants(X::AbstractMatrix)\n\nReturns cumulant matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.estimate_cumulants-Tuple{ICA_BlindSourceSeparation.sensorData, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.estimate_cumulants","text":"Estimation of cumulant matrices\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.gradient-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.gradient","text":"gradient(Y, psiY)\ncomputes the gradient of the contrast function with respect to the input signals.\n# Arguments\n- `Y::AbstractMatrix{<:Real}`: an `N×T` matrix where each row is a signal component over `T` samples.\n- `psiY::AbstractMatrix{<:Real}`: the elementwise derivative of the contrast function, same size as `Y`.\n# Returns\n- An `N×N` matrix representing the relative gradient\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.ica_jade-Tuple{ICA_BlindSourceSeparation.sensorData, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.ica_jade","text":"JADE Algorithm for ICA source separation\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.ica_shibbs-Tuple{ICA_BlindSourceSeparation.sensorData, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.ica_shibbs","text":"ica_shibbs(dataset::sensorData, m::Integer)\n\nOuter loop of the shibbs algorithm. Whitens data and loops untile diagonalization result is within threshold. Returns the dataset combined with transformation matrix as well as the transformation Matrix\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.joint_diagonalize-Tuple{AbstractMatrix, Number, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.joint_diagonalize","text":"joint_diagonalize(CM::AbstractMatrix, seuil::Float64)\n\nReturns diagonalization matrix and rotation size\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.l_bfgs_direction-NTuple{5, Any}","page":"Home","title":"ICA_BlindSourceSeparation.l_bfgs_direction","text":"l_bfgs_direction(G, h, s_list, y_list, r_list)\ncomputes a search direction using the limited-memory BFGS (L-BFGS) algorithm.\n# Arguments\n- `G::AbstractVector{<:Real}`: the current gradient.\n- `h::AbstractVector{<:Real}`: a diagonal approximation to the Hessian.\n- `s_list::Vector{AbstractVector{<:Real}}`: list of previous update vectors.\n- `y_list::Vector{AbstractVector{<:Real}}`: list of previous gradient differences.\n- `r_list::Vector{Float64}`: list of scalars for each pair `(s, y)`.\n# Returns\n- the descent direction computed using the L-BFGS two-loop recursion.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.line_search-NTuple{4, Any}","page":"Home","title":"ICA_BlindSourceSeparation.line_search","text":"function line_search(Y, direction, signs, current_loss; ls_tries)\nPerform a backtracking line search using a matrix exponential update.\n# Arguments\n- `Y::AbstractMatrix{<:Real}`: current signal matrix (`N×T`).\n- `direction::AbstractMatrix{<:Real}`: descent direction matrix of the same size as `Y`.\n- `signs::AbstractMatrix{<:Real}`: sign weights for the loss, same size as `Y`.\n- `current_loss::Real`: current loss value, or `Inf` to force recomputation.\n- `ls_tries::Integer` (keyword): maximum number of backtracking steps.\n# Returns\n- A tuple `(converged, Y_new, new_loss, alpha)` where\n- `converged::Bool` indicates whether a successful step was found,\n- `Y_new::AbstractMatrix{<:Real}` is the updated signal matrix (or original if no step succeeded),\n- `new_loss::Real` is the loss at `Y_new`,\n- `alpha::Real` is the final step size.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.loss-Tuple{Any, Any}","page":"Home","title":"ICA_BlindSourceSeparation.loss","text":"loss(Y, signs)\ncomputes the total loss for a set of signals.\n# Arguments\n- `Y::AbstractMatrix{<:Real}`: matrix of shape `N×T`, where each row is a signal component over `T` samples.\n- `signs::AbstractMatrix{<:Real}`: matrix of the same shape as `Y`, containing signs or weights for each signal value.\n# Returns\n- A scalar representing the average contrast-based loss across all components and time steps.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.plot_dataset-Tuple{ICA_BlindSourceSeparation.sensorData}","page":"Home","title":"ICA_BlindSourceSeparation.plot_dataset","text":"plot_matrix(dataset::sensorData)\n\nPlots each column of the dataset against the timestamp vector\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.proj_hessian_approx-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.proj_hessian_approx","text":"proj_hessian_approx(Y, psidY_mean, G)\ncomputes an approximation of the projected Hessian matrix.\n# Arguments\n- `Y::AbstractMatrix{<:Real}`: an `N×T` matrix of current signal components.\n- `psidY_mean::AbstractVector{<:Real}`: a length-`N` vector containing the average of the second derivative (or negative squared derivative) of the contrast function for each component.\n- `G::AbstractMatrix{<:Real}`: the gradient matrix of size `N×N`.\n# Returns\n- An `N×N` symmetric matrix approximating the projected Hessian.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.read_dataset-Tuple{String}","page":"Home","title":"ICA_BlindSourceSeparation.read_dataset","text":"read_dataset(filename::String) -> sensorData\n\nReads a file containing numbers separated by spaces or tabs. Number of columns is detected by analyzing the first valid line. Returns an instance of sensorData.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.regularize_hessian-Tuple{AbstractMatrix{<:Real}, Real}","page":"Home","title":"ICA_BlindSourceSeparation.regularize_hessian","text":"regularize_hessian(h, lambda_min)\nclips the diagonal values of the Hessian approximation from below, ensuring all values are at least `lambda_min`.\n# Arguments\n- `h::AbstractMatrix{<:Real}`: a diagonal matrix, where diagonal elements approximate eigenvalues.\n- `lambda_min::Real`: minimum allowed eigenvalue\n# Returns\n- A matrix of the same size as `h`, with all values less than `lambda_min` replaced by `lambda_min`\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.score-Tuple{AbstractArray{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.score","text":"core(Y::AbstractArray{<:Real})\napplies the hyperbolic tangent elementwise to each entry of `Y`.\n# Arguments\n- `Y::AbstractArray{<:Real}`: input array (vector, matrix, or higher‑dimensional array) of real numbers.\n# Returns\n- an array with the same shape as `Y`, where each element is `tanh(y)`.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.score_der-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.score_der","text":"core_der(psiY::AbstractMatrix{<:Real})\ncomputes the average derivative of the hyperbolic tangent nonlinearity for each row of `psiY`.\n# Arguments\n- `psiY::AbstractMatrix{<:Real}`: input array of size `N×T`, where each row is a signal component over `T` observations.\n# Returns\n- an `N×1` array in which each entry  represents the average derivative of the `tanh` nonlinearity, evaluated at each value in the corresponding row of `psiY`.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.solve_hessian-Tuple{Any, Any}","page":"Home","title":"ICA_BlindSourceSeparation.solve_hessian","text":"solve_hessian(G, h)\ncomputes the product of the inverse Hessian approximation with the gradient.\n# Arguments\n- `G::AbstractMatrix{<:Real}`: the gradient matrix.\n- `h::AbstractMatrix{<:Real}`: diagonal approximation of the Hessian.\n# Returns\n- A matrix of same size as `G`, where each element is `G[i,j] / h[i,j]`.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.sort_by_energy-Tuple{AbstractMatrix}","page":"Home","title":"ICA_BlindSourceSeparation.sort_by_energy","text":"sort_by_energy(B::AbstractMatrix)\n\nSort rows of B to put most energetic sources first Returns sorted matrix\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.whiten_dataset-Tuple{ICA_BlindSourceSeparation.sensorData, Int64}","page":"Home","title":"ICA_BlindSourceSeparation.whiten_dataset","text":"whiten_dataset(X::sensorData, m::Int64) -> sensorData, W::Matrix{Float64}, iW::Matrix{Float64}\n\nApplies PCA whitening to TxN data matrix to decorrelate m sources T: number of samples n: number of sensors m: number of sources Returns the whitened dataset (Txm data matrix), whitening matrix W (mxn), pseudo-inverse whitening matrix iW (nxm)\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.whiten_dataset-Tuple{ICA_BlindSourceSeparation.sensorData}","page":"Home","title":"ICA_BlindSourceSeparation.whiten_dataset","text":"whiten_dataset(X::sensorData)\n\nApplies PCA whitening to TxN data matrix T: number of samples N: number of sensors Returns the whitened dataset.\n\n\n\n\n\n","category":"method"}]
}

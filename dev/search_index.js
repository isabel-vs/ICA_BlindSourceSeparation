var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This package provides multiple algorithms for Blind Source Separation.  At this time the user can choose between JADE, Shibbs and Picard. ","category":"page"},{"location":"getting_started/#How-to-use-the-datatype-SensorData","page":"Getting Started","title":"How to use the datatype SensorData","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Key to using the package is the SensorData datatype. The user can either create a SensorData instance by loading it from disk using the readdataset() function, or he can construct his own by provididing an array of timestamps of length N and a corresponding matrix of size NxM, where M is the amount of sensors in the dataset. When the user has created a SensorData instance, he can pass it to the whitening function, plot it or perform the Blind Source separation using the performseparation function.","category":"page"},{"location":"getting_started/#Code-Example","page":"Getting Started","title":"Code Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Load a dataset from disk","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = read_dataset(\"data/foetal_ecg.dat\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Perform whitening on the dataset","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = whiten_dataset(x)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Plot dataset","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"plot_dataset(x)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Prepare JADE algorithm","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algo = Jade(size(x.data, 2))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Prepare Shibbs algorithm","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algo = Shibbs(2, 1000)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Prepare Picard algorithm","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algo = Picard(3, 200, 1e-6, 1e-2, 10, true)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Run source separation","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = perform_separation(x, algo)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Plot again","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"plot_dataset(x)","category":"page"},{"location":"getting_started/#Complete-example:","page":"Getting Started","title":"Complete example:","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This example plots the original whitened data, as well as the results of Jade, Shibbs and Picard algorithm.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = read_dataset(\"data/foetal_ecg.dat\")\nx = whiten_dataset(x)\nplot_dataset(x)\n\nalgo = Jade(size(x.data, 2))\ny = perform_separation(x, algo)\nplot_dataset(y)\n\nalgo = Shibbs(2, 1000)\nz, _ = perform_separation(x, algo)\nplot_dataset(z)\n\nalgo = Picard(3, 200, 1e-6, 1e-2, 10, true)\nr = perform_separation(x, algo)\nplot_dataset(r)","category":"page"},{"location":"#ICA_BlindSourceSeparation","page":"Home","title":"ICA_BlindSourceSeparation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ICA_BlindSourceSeparation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ICA_BlindSourceSeparation.demo-Tuple{}","page":"Home","title":"ICA_BlindSourceSeparation.demo","text":"demo()\n\nPlots the whitened data in the foetal_ecg database.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.estimate_cumulants-Tuple{AbstractMatrix}","page":"Home","title":"ICA_BlindSourceSeparation.estimate_cumulants","text":"estimate_cumulants(X::AbstractMatrix)\n\nReturns cumulant matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.estimate_cumulants-Tuple{sensorData, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.estimate_cumulants","text":"Estimation of cumulant matrices\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.gradient-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.gradient","text":"gradient(Y, psiY)\n\nCompute the gradient of the contrast function with respect to the input signals.\n\nArguments\n\nY::AbstractMatrix{<:Real}: an N×T matrix where each row is a signal component over T samples.\npsiY::AbstractMatrix{<:Real}: the elementwise derivative of the contrast function, same size as Y.\n\nReturns\n\nAn N×N matrix representing the relative gradient\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.ica_jade-Tuple{sensorData, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.ica_jade","text":"JADE Algorithm for ICA source separation\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.ica_shibbs-Tuple{sensorData, Integer, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.ica_shibbs","text":"ica_shibbs(dataset::sensorData, m::Integer, maxSteps::Integer)\n\nOuter loop of the shibbs algorithm. Whitens data and loops untile diagonalization result is within threshold. Returns the dataset combined with transformation matrix as well as the transformation Matrix\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.joint_diagonalize-Tuple{AbstractMatrix, Real, Integer}","page":"Home","title":"ICA_BlindSourceSeparation.joint_diagonalize","text":"joint_diagonalize(CM_in::AbstractMatrix, thresh::Real, max_iters::Integer)\n\nReturns diagonalization matrix and rotation size\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.l_bfgs_direction-NTuple{5, Any}","page":"Home","title":"ICA_BlindSourceSeparation.l_bfgs_direction","text":"l_bfgs_direction(G, h, s_list, y_list, r_list)\n\nCompute a search direction using the limited-memory BFGS (L-BFGS) algorithm.\n\nArguments\n\n`G::AbstractMatrix{<:Real}: the current gradient.\nh::AbstractMatrix{<:Real}: a diagonal approximation to the Hessian.\ns_list::Vector{AbstractMatrix{<:Real}}: list of previous update vectors.\ny_list::Vector{AbstractMatrix{<:Real}}: list of previous gradient differences.\nr_list::Vector{Float64}: list of scalars for each pair (s, y).\n\nReturns\n\nthe descent direction computed using the L-BFGS two-loop recursion.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.line_search-NTuple{4, Any}","page":"Home","title":"ICA_BlindSourceSeparation.line_search","text":"function line_search(Y, direction, signs, current_loss; ls_tries)\n\nPerform a backtracking line search using a matrix exponential update.\n\nArguments\n\nY::AbstractMatrix{<:Real}: current signal matrix (N×T).\ndirection::AbstractMatrix{<:Real}: descent direction matrix of the same size as Y.\nsigns::AbstractVector{<:Real}: sign weights for the loss, same size as Y.\ncurrent_loss::Real: current loss value, or Inf to force recomputation.\nls_tries::Integer (keyword): maximum number of backtracking steps.\n\nReturns\n\nA tuple (converged, Y_new, new_loss, alpha) where\nconverged::Bool indicates whether a successful step was found,\nY_new::AbstractMatrix{<:Real} is the updated signal matrix (or original if no step succeeded),\nnew_loss::Real is the loss at Y_new,\nalpha::Real is the final step size.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.loss-Tuple{Any, Any}","page":"Home","title":"ICA_BlindSourceSeparation.loss","text":"loss(Y, signs)\n\nCompute the total loss for a set of signals.\n\nArguments\n\nY::AbstractMatrix{<:Real}: matrix of shape N×T, where each row is a signal component over T samples.\nsigns::AbstractMatrix{<:Real}: matrix of the same shape as Y, containing signs or weights for each signal value.\n\nReturns\n\nA scalar representing the average contrast-based loss across all components and time steps.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.plot_dataset-Tuple{sensorData}","page":"Home","title":"ICA_BlindSourceSeparation.plot_dataset","text":"plot_matrix(dataset::sensorData)\n\nPlots each column of the dataset against the timestamp vector\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.proj_hessian_approx-Tuple{AbstractMatrix{<:Real}, AbstractVector{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.proj_hessian_approx","text":"proj_hessian_approx(Y, psidY_mean, G)\n\nCompute an approximation of the projected Hessian matrix.\n\nArguments\n\nY::AbstractMatrix{<:Real}: an N×T matrix of current signal components.\npsidY_mean::AbstractVector{<:Real}: a length-N vector containing the average of the second derivative (or negative squared derivative) of the contrast function for each component.\nG::AbstractMatrix{<:Real}: the gradient matrix of size N×N.\n\nReturns\n\nAn N×N symmetric matrix approximating the projected Hessian.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.read_dataset-Tuple{String}","page":"Home","title":"ICA_BlindSourceSeparation.read_dataset","text":"read_dataset(filename::String) -> sensorData\n\nReads a file containing numbers separated by spaces or tabs. Number of columns is detected by analyzing the first valid line. Returns an instance of sensorData.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.regularize_hessian-Tuple{AbstractMatrix{<:Real}, Real}","page":"Home","title":"ICA_BlindSourceSeparation.regularize_hessian","text":"regularize_hessian(h, lambda_min)\n\nClip the diagonal values of the Hessian approximation from below, ensuring all values are at least lambda_min.\n\nArguments\n\nh::AbstractMatrix{<:Real}: a diagonal matrix, where diagonal elements approximate eigenvalues.\nlambda_min::Real: minimum allowed eigenvalue\n\nReturns\n\nA matrix of the same size as h, with all values less than lambda_min replaced by lambda_min\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.score-Tuple{AbstractArray{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.score","text":"score(Y::AbstractArray{<:Real})\n\nApply the hyperbolic tangent elementwise to each entry of Y.\n\nArguments\n\nY::AbstractArray{<:Real}: input array (vector, matrix, or higher‑dimensional array) of real numbers.\n\nReturns\n\nan array with the same shape as Y, where each element is tanh(y).\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.score_der-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.score_der","text":"score_der(psiY::AbstractMatrix{<:Real})\n\nComputes the average derivative of the hyperbolic tangent nonlinearity for each row of psiY.\n\nArguments\n\npsiY::AbstractMatrix{<:Real}: input array of size N×T, where each row is a signal component over T observations.\n\nReturns\n\na vebtor in which each entry  represents the average derivative of the tanh nonlinearity, evaluated at each value in the corresponding row of psiY.\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.solve_hessian-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"ICA_BlindSourceSeparation.solve_hessian","text":"solve_hessian(G, h)\n\nCompute the product of the inverse Hessian approximation with the gradient.\n\nArguments\n\nG::AbstractMatrix{<:Real}: the gradient matrix.\nh::AbstractMatrix{<:Real}: diagonal approximation of the Hessian.\n\nReturns\n\nA matrix of same size as G, where each element is G[i,j] / h[i,j].\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.sort_by_energy-Tuple{AbstractMatrix}","page":"Home","title":"ICA_BlindSourceSeparation.sort_by_energy","text":"sort_by_energy(B::AbstractMatrix)\n\nSort rows of B to put most energetic sources first Returns sorted matrix\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.whiten_dataset-Tuple{sensorData, Int64}","page":"Home","title":"ICA_BlindSourceSeparation.whiten_dataset","text":"whiten_dataset(X::sensorData, m::Int64) -> sensorData, W::Matrix{Float64}, iW::Matrix{Float64}\n\nApplies PCA whitening to TxN data matrix to decorrelate m sources T: number of samples n: number of sensors m: number of sources Returns the whitened dataset (Txm data matrix), whitening matrix W (mxn), pseudo-inverse whitening matrix iW (nxm)\n\n\n\n\n\n","category":"method"},{"location":"#ICA_BlindSourceSeparation.whiten_dataset-Tuple{sensorData}","page":"Home","title":"ICA_BlindSourceSeparation.whiten_dataset","text":"whiten_dataset(X::sensorData)\n\nApplies PCA whitening to TxN data matrix T: number of samples N: number of sensors Returns the whitened dataset.\n\n\n\n\n\n","category":"method"}]
}
